/*****************************************************************************

Copyright (c) 1994, 2018, Oracle and/or its affiliates. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License, version 2.0, as published by the
Free Software Foundation.

This program is also distributed with certain software (including but not
limited to OpenSSL) that is licensed under separate terms, as designated in a
particular file or component or in included license documentation. The authors
of MySQL hereby grant you an additional permission to link the program and
your derivative works with the separately licensed software that they have
included with MySQL.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License, version 2.0,
for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA

*****************************************************************************/

/** @file include/data0data.ic
 SQL data field and tuple

 Created 5/30/1994 Heikki Tuuri
 **********************************
***************************************/

#include <innodb/memory/mem_heap_free.h>
#include <innodb/memory/mem_heap_zalloc.h>
#include <innodb/memory/mem_heap_dup.h>
#include <innodb/memory_check/memory_check.h>
#include <innodb/memory/mem_heap_t.h>
#include <innodb/data_types/dtype_set.h>
#include <innodb/data_types/dtype_get_sql_null_size.h>
#include <innodb/data_types/flags.h>
#include <innodb/machine/data.h>
#include <innodb/random/random.h>
#include "btr0types.h"




#ifdef UNIV_DEBUG
/** Dummy variable to catch access to uninitialized fields.  In the
debug version, dtuple_create() will make all fields of dtuple_t point
to data_error. */
extern byte data_error;

/** Gets pointer to the type struct of SQL data field.
 @return pointer to the type struct */
UNIV_INLINE
dtype_t *dfield_get_type(const dfield_t *field) /*!< in: SQL data field */
{
  ut_ad(field);

  return ((dtype_t *)&(field->type));
}
#endif /* UNIV_DEBUG */















































/** Creates a data tuple from an already allocated chunk of memory.
The size of the chunk must be at least DTUPLE_EST_ALLOC(n_fields).
The default value for number of fields used in record comparisons
for this tuple is n_fields.
@param[in,out]	buf		buffer to use
@param[in]	buf_size	buffer size
@param[in]	n_fields	number of field
@param[in]	n_v_fields	number of fields on virtual columns
@return created tuple (inside buf) */
UNIV_INLINE
dtuple_t *dtuple_create_from_mem(void *buf, ulint buf_size, ulint n_fields,
                                 ulint n_v_fields) {
  dtuple_t *tuple;
  ulint n_t_fields = n_fields + n_v_fields;

  ut_ad(buf != NULL);
  ut_a(buf_size >= DTUPLE_EST_ALLOC(n_t_fields));

  tuple = (dtuple_t *)buf;
  tuple->info_bits = 0;
  tuple->n_fields = n_fields;
  tuple->n_v_fields = n_v_fields;
  tuple->n_fields_cmp = n_fields;
  tuple->fields = (dfield_t *)&tuple[1];
  if (n_v_fields > 0) {
    tuple->v_fields = &tuple->fields[n_fields];
  } else {
    tuple->v_fields = NULL;
  }

#ifdef UNIV_DEBUG
  tuple->magic_n = DATA_TUPLE_MAGIC_N;

  { /* In the debug version, initialize fields to an error value */
    ulint i;

    for (i = 0; i < n_t_fields; i++) {
      dfield_t *field;

      if (i >= n_fields) {
        field = dtuple_get_nth_v_field(tuple, i - n_fields);
      } else {
        field = dtuple_get_nth_field(tuple, i);
      }

      dfield_set_len(field, UNIV_SQL_NULL);
      field->data = &data_error;
      dfield_get_type(field)->mtype = DATA_ERROR;
      dfield_get_type(field)->prtype = DATA_ERROR;
    }
  }
#endif
  UNIV_MEM_ASSERT_W(tuple->fields, n_t_fields * sizeof *tuple->fields);
  UNIV_MEM_INVALID(tuple->fields, n_t_fields * sizeof *tuple->fields);
  return (tuple);
}

/** Duplicate the virtual field data in a dtuple_t
@param[in,out]		vrow	dtuple contains the virtual fields
@param[in]		heap	heap memory to use */
UNIV_INLINE
void dtuple_dup_v_fld(const dtuple_t *vrow, mem_heap_t *heap) {
  for (ulint i = 0; i < vrow->n_v_fields; i++) {
    dfield_t *dfield = dtuple_get_nth_v_field(vrow, i);
    dfield_dup(dfield, heap);
  }
}

/** Initialize the virtual field data in a dtuple_t
@param[in,out]		vrow	dtuple contains the virtual fields */
UNIV_INLINE
void dtuple_init_v_fld(const dtuple_t *vrow) {
  for (ulint i = 0; i < vrow->n_v_fields; i++) {
    dfield_t *dfield = dtuple_get_nth_v_field(vrow, i);
    dfield_get_type(dfield)->mtype = DATA_MISSING;
    dfield_set_len(dfield, UNIV_SQL_NULL);
  }
}

/** Creates a data tuple to a memory heap. The default value for number
 of fields used in record comparisons for this tuple is n_fields.
 @return own: created tuple */
UNIV_INLINE
dtuple_t *dtuple_create(
    mem_heap_t *heap, /*!< in: memory heap where the tuple
                      is created, DTUPLE_EST_ALLOC(n_fields)
                      bytes will be allocated from this heap */
    ulint n_fields)   /*!< in: number of fields */
{
  return (dtuple_create_with_vcol(heap, n_fields, 0));
}

/** Creates a data tuple with virtual columns to a memory heap.
@param[in]	heap		memory heap where the tuple is created
@param[in]	n_fields	number of fields
@param[in]	n_v_fields	number of fields on virtual col
@return own: created tuple */
UNIV_INLINE
dtuple_t *dtuple_create_with_vcol(mem_heap_t *heap, ulint n_fields,
                                  ulint n_v_fields) {
  void *buf;
  ulint buf_size;
  dtuple_t *tuple;

  ut_ad(heap);

  buf_size = DTUPLE_EST_ALLOC(n_fields + n_v_fields);
  buf = mem_heap_zalloc(heap, buf_size);

  tuple = dtuple_create_from_mem(buf, buf_size, n_fields, n_v_fields);

#ifdef UNIV_DEBUG
  tuple->m_heap = heap;
#endif /* UNIV_DEBUG */

  return (tuple);
}

/** Copies a data tuple's virtual fields to another. This is a shallow copy;
@param[in,out]	d_tuple		destination tuple
@param[in]	s_tuple		source tuple */
UNIV_INLINE
void dtuple_copy_v_fields(dtuple_t *d_tuple, const dtuple_t *s_tuple) {
  ulint n_v_fields = dtuple_get_n_v_fields(d_tuple);
  ut_ad(n_v_fields == dtuple_get_n_v_fields(s_tuple));

  for (ulint i = 0; i < n_v_fields; i++) {
    dfield_copy(dtuple_get_nth_v_field(d_tuple, i),
                dtuple_get_nth_v_field(s_tuple, i));
  }
}

/** Copies a data tuple to another.  This is a shallow copy; if a deep copy
 is desired, dfield_dup() will have to be invoked on each field.
 @return own: copy of tuple */
UNIV_INLINE
dtuple_t *dtuple_copy(const dtuple_t *tuple, /*!< in: tuple to copy from */
                      mem_heap_t *heap)      /*!< in: memory heap
                                             where the tuple is created */
{
  ulint n_fields = dtuple_get_n_fields(tuple);
  ulint n_v_fields = dtuple_get_n_v_fields(tuple);
  dtuple_t *new_tuple = dtuple_create_with_vcol(heap, n_fields, n_v_fields);
  ulint i;

  for (i = 0; i < n_fields; i++) {
    dfield_copy(dtuple_get_nth_field(new_tuple, i),
                dtuple_get_nth_field(tuple, i));
  }

  for (i = 0; i < n_v_fields; i++) {
    dfield_copy(dtuple_get_nth_v_field(new_tuple, i),
                dtuple_get_nth_v_field(tuple, i));
  }

  return (new_tuple);
}

/** The following function returns the sum of data lengths of a tuple. The space
 occupied by the field structs or the tuple struct is not counted. Neither
 is possible space in externally stored parts of the field.
 @return sum of data lengths */
UNIV_INLINE
ulint dtuple_get_data_size(const dtuple_t *tuple, /*!< in: typed data tuple */
                           ulint comp) /*!< in: nonzero=ROW_FORMAT=COMPACT  */
{
  const dfield_t *field;
  ulint n_fields;
  ulint len;
  ulint i;
  ulint sum = 0;

  ut_ad(tuple);
  ut_ad(dtuple_check_typed(tuple));
  ut_ad(tuple->magic_n == DATA_TUPLE_MAGIC_N);

  n_fields = tuple->n_fields;

  for (i = 0; i < n_fields; i++) {
    field = dtuple_get_nth_field(tuple, i);
    len = dfield_get_len(field);

    if (len == UNIV_SQL_NULL) {
      len = dtype_get_sql_null_size(dfield_get_type(field), comp);
    }

    sum += len;
  }

  return (sum);
}

/** Computes the number of externally stored fields in a data tuple.
 @return number of externally stored fields */
UNIV_INLINE
ulint dtuple_get_n_ext(const dtuple_t *tuple) /*!< in: tuple */
{
  ulint n_ext = 0;
  ulint n_fields = tuple->n_fields;
  ulint i;

  ut_ad(tuple);
  ut_ad(dtuple_check_typed(tuple));
  ut_ad(tuple->magic_n == DATA_TUPLE_MAGIC_N);

  for (i = 0; i < n_fields; i++) {
    n_ext += dtuple_get_nth_field(tuple, i)->ext;
  }

  return (n_ext);
}

/** Sets types of fields binary in a tuple. */
UNIV_INLINE
void dtuple_set_types_binary(dtuple_t *tuple, /*!< in: data tuple */
                             ulint n) /*!< in: number of fields to set */
{
  dtype_t *dfield_type;
  ulint i;

  for (i = 0; i < n; i++) {
    dfield_type = dfield_get_type(dtuple_get_nth_field(tuple, i));
    dtype_set(dfield_type, DATA_BINARY, 0, 0);
  }
}

/** Compute a hash value of a prefix of an index record.
@param[in]	tuple		index record
@param[in]	n_fields	number of fields to include
@param[in]	n_bytes		number of bytes to fold in the last field
@param[in]	fold		fold value of the index identifier
@return the folded value */
UNIV_INLINE
ulint dtuple_fold(const dtuple_t *tuple, ulint n_fields, ulint n_bytes,
                  ulint fold) {
  const dfield_t *field;
  ulint i;
  const byte *data;
  ulint len;

  ut_ad(tuple);
  ut_ad(tuple->magic_n == DATA_TUPLE_MAGIC_N);
  ut_ad(dtuple_check_typed(tuple));

  for (i = 0; i < n_fields; i++) {
    field = dtuple_get_nth_field(tuple, i);

    data = (const byte *)dfield_get_data(field);
    len = dfield_get_len(field);

    if (len != UNIV_SQL_NULL) {
      fold = ut_fold_ulint_pair(fold, ut_fold_binary(data, len));
    }
  }

  if (n_bytes > 0) {
    field = dtuple_get_nth_field(tuple, i);

    data = (const byte *)dfield_get_data(field);
    len = dfield_get_len(field);

    if (len != UNIV_SQL_NULL) {
      if (len > n_bytes) {
        len = n_bytes;
      }

      fold = ut_fold_ulint_pair(fold, ut_fold_binary(data, len));
    }
  }

  return (fold);
}



/** Checks if a dtuple contains an SQL null value.
 @return true if some field is SQL null */
UNIV_INLINE
ibool dtuple_contains_null(const dtuple_t *tuple) /*!< in: dtuple */
{
  ulint n;
  ulint i;

  n = dtuple_get_n_fields(tuple);

  for (i = 0; i < n; i++) {
    if (dfield_is_null(dtuple_get_nth_field(tuple, i))) {
      return (TRUE);
    }
  }

  return (FALSE);
}

/** Frees the memory in a big rec vector. */
UNIV_INLINE
void dtuple_big_rec_free(big_rec_t *vector) /*!< in, own: big rec vector; it is
                                            freed in this function */
{
  mem_heap_free(vector->heap);
}
