/*****************************************************************************

Copyright (c) 1994, 2019, Oracle and/or its affiliates. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License, version 2.0, as published by the
Free Software Foundation.

This program is also distributed with certain software (including but not
limited to OpenSSL) that is licensed under separate terms, as designated in a
particular file or component or in included license documentation. The authors
of MySQL hereby grant you an additional permission to link the program and
your derivative works with the separately licensed software that they have
included with MySQL.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License, version 2.0,
for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA

*****************************************************************************/

/** @file include/rem0rec.ic
 Record manager

 Created 5/30/1994 Heikki Tuuri
 *************************************************************************/

#include <innodb/memory/ut_memcpy.h>

#include "btr0types.h"
#include "dict0boot.h"
#include "dict0dict.h"
#include "page0types.h"
#include <innodb/machine/data.h>


/* Offsets of the bit-fields in an old-style record. NOTE! In the table the
most significant bytes and bits are written below less significant.

        (1) byte offset		(2) bit usage within byte
        downward from
        origin ->	1	8 bits pointer to next record
                        2	8 bits pointer to next record
                        3	1 bit short flag
                                7 bits number of fields
                        4	3 bits number of fields
                                5 bits heap number
                        5	8 bits heap number
                        6	4 bits n_owned
                                4 bits info bits
*/

/* Offsets of the bit-fields in a new-style record. NOTE! In the table the
most significant bytes and bits are written below less significant.

        (1) byte offset		(2) bit usage within byte
        downward from
        origin ->	1	8 bits relative offset of next record
                        2	8 bits relative offset of next record
                                  the relative offset is an unsigned 16-bit
                                  integer:
                                  (offset_of_next_record
                                   - offset_of_this_record) mod 64Ki,
                                  where mod is the modulo as a non-negative
                                  number;
                                  we can calculate the offset of the next
                                  record with the formula:
                                  relative_offset + offset_of_this_record
                                  mod UNIV_PAGE_SIZE
                        3	3 bits status:
                                        000=conventional record
                                        001=node pointer record (inside B-tree)
                                        010=infimum record
                                        011=supremum record
                                        1xx=reserved
                                5 bits heap number
                        4	8 bits heap number
                        5	4 bits n_owned
                                4 bits info bits
*/


/** The following function is used to set the number of owned records. */
UNIV_INLINE
void rec_set_n_owned_new(
    rec_t *rec,               /*!< in/out: new-style physical record */
    page_zip_des_t *page_zip, /*!< in/out: compressed page, or NULL */
    ulint n_owned)            /*!< in: the number of owned */
{
  rec_set_bit_field_1(rec, n_owned, REC_NEW_N_OWNED, REC_N_OWNED_MASK,
                      REC_N_OWNED_SHIFT);
  if (page_zip && rec_get_status(rec) != REC_STATUS_SUPREMUM) {
    page_zip_rec_set_owned(page_zip, rec, n_owned);
  }
}


/** The following function is used to set the deleted bit. */
UNIV_INLINE
void rec_set_deleted_flag_new(
    rec_t *rec,               /*!< in/out: new-style physical record */
    page_zip_des_t *page_zip, /*!< in/out: compressed page, or NULL */
    ulint flag)               /*!< in: nonzero if delete marked */
{
  ulint val;

  val = rec_get_info_bits(rec, TRUE);

  if (flag) {
    val |= REC_INFO_DELETED_FLAG;
  } else {
    val &= ~REC_INFO_DELETED_FLAG;
  }

  rec_set_info_bits_new(rec, val);

  if (page_zip) {
    page_zip_rec_set_deleted(page_zip, rec, flag);
  }
}



/** Determine if the offsets are for a record containing null BLOB pointers.
 @return first field containing a null BLOB pointer, or NULL if none found */
UNIV_INLINE
const byte *rec_offs_any_null_extern(
    const rec_t *rec,     /*!< in: record */
    const ulint *offsets) /*!< in: rec_get_offsets(rec) */
{
  ulint i;
  ut_ad(rec_offs_validate(rec, NULL, offsets));

  if (!rec_offs_any_extern(offsets)) {
    return (NULL);
  }

  for (i = 0; i < rec_offs_n_fields(offsets); i++) {
    if (rec_offs_nth_extern(offsets, i)) {
      ulint len;
      const byte *field = rec_get_nth_field(rec, offsets, i, &len);

      ut_a(len >= BTR_EXTERN_FIELD_REF_SIZE);
      if (!memcmp(field + len - BTR_EXTERN_FIELD_REF_SIZE, field_ref_zero,
                  BTR_EXTERN_FIELD_REF_SIZE)) {
        return (field);
      }
    }
  }

  return (NULL);
}











/** The following function returns the size of a data tuple when converted to
 a physical record.
 @return size */
UNIV_INLINE
ulint rec_get_converted_size(
    const dict_index_t *index, /*!< in: record descriptor */
    const dtuple_t *dtuple,    /*!< in: data tuple */
    ulint n_ext)               /*!< in: number of externally stored columns */
{
  ulint data_size;
  ulint extra_size;

  ut_ad(index);
  ut_ad(dtuple);
  ut_ad(dtuple_check_typed(dtuple));

  ut_ad(dict_index_is_ibuf(index)

        /* If this is an instant index and the tuple comes from
        UPDATE, its fields could be less than index definition */
        || index->has_instant_cols()

        || dtuple_get_n_fields(dtuple) ==
               (((dtuple_get_info_bits(dtuple) & REC_NEW_STATUS_MASK) ==
                 REC_STATUS_NODE_PTR)
                    ? dict_index_get_n_unique_in_tree_nonleaf(index) + 1
                    : dict_index_get_n_fields(index))

        /* a record for older SYS_INDEXES table
        (missing merge_threshold column) is acceptable. */
        || (index->table->id == DICT_INDEXES_ID &&
            dtuple_get_n_fields(dtuple) == dict_index_get_n_fields(index) - 1));

  if (dict_table_is_comp(index->table)) {
    return (rec_get_converted_size_comp(
        index, dtuple_get_info_bits(dtuple) & REC_NEW_STATUS_MASK,
        dtuple->fields, dtuple->n_fields, NULL));
  }

  data_size = dtuple_get_data_size(dtuple, 0);

  extra_size = rec_get_converted_extra_size(data_size,
                                            dtuple_get_n_fields(dtuple), n_ext);

#if 0
    /* This code is inactive since it may be the wrong place to add
    in the size of node pointers used in parent pages AND it is not
    currently needed since ha_innobase::max_supported_key_length()
    ensures that the key size limit for each page size is well below
    the actual limit ((free space on page / 4) - record overhead).
    But those limits will need to be raised when InnoDB can
    support multiple page sizes.  At that time, we will need
    to consider the node pointer on these universal btrees. */

    if (dict_index_is_ibuf(index)) {
        /* This is for the insert buffer B-tree.
        All fields in the leaf tuple ascend to the
        parent node plus the child page pointer. */

        /* ibuf cannot contain externally stored fields */
        ut_ad(n_ext == 0);

        /* Add the data pointer and recompute extra_size
        based on one more field. */
        data_size += REC_NODE_PTR_SIZE;
        extra_size = rec_get_converted_extra_size(
            data_size,
            dtuple_get_n_fields(dtuple) + 1,
            0);

        /* Be sure dtuple->n_fields has this node ptr
        accounted for.  This function should correspond to
        what rec_convert_dtuple_to_rec() needs in storage.
        In optimistic insert or update-not-in-place, we will
        have to ensure that if the record is converted to a
        node pointer, it will not become too large.*/
    }
#endif

  return (data_size + extra_size);
}

















#ifndef UNIV_HOTBACKUP
/** Compute a hash value of a prefix of a leaf page record.
@param[in]	rec		leaf page record
@param[in]	offsets		rec_get_offsets(rec)
@param[in]	n_fields	number of complete fields to fold
@param[in]	n_bytes		number of bytes to fold in the last field
@param[in]	fold		fold value of the index identifier
@param[in]	index		index where the record resides
@return the folded value */
UNIV_INLINE
ulint rec_fold(const rec_t *rec, const ulint *offsets, ulint n_fields,
               ulint n_bytes, ulint fold, const dict_index_t *index) {
  uint16_t i;
  const byte *data;
  ulint len;
  ulint n_fields_rec;

  ut_ad(rec_offs_validate(rec, NULL, offsets));
  ut_ad(rec_validate(rec, offsets));
  ut_ad(n_fields > 0 || n_bytes > 0);

  n_fields_rec = rec_offs_n_fields(offsets);
  ut_ad(n_fields <= n_fields_rec);
  ut_ad(n_fields < n_fields_rec || n_bytes == 0);

  if (n_fields > n_fields_rec) {
    n_fields = n_fields_rec;
  }

  if (n_fields == n_fields_rec) {
    n_bytes = 0;
  }

  for (i = 0; i < n_fields; i++) {
    data = rec_get_nth_field_instant(rec, offsets, i, index, &len);

    if (len != UNIV_SQL_NULL) {
      fold = ut_fold_ulint_pair(fold, ut_fold_binary(data, len));
    }
  }

  if (n_bytes > 0) {
    data = rec_get_nth_field_instant(rec, offsets, i, index, &len);

    if (len != UNIV_SQL_NULL) {
      if (len > n_bytes) {
        len = n_bytes;
      }

      fold = ut_fold_ulint_pair(fold, ut_fold_binary(data, len));
    }
  }

  return (fold);
}
#endif /* !UNIV_HOTBACKUP */

/** Get the length of the number of fields for any new style record.
@param[in]	n_fields	number of fields in the record
@return	length of specified number of fields */
UNIV_INLINE
uint8_t rec_get_n_fields_length(ulint n_fields) {
  return (n_fields > REC_N_FIELDS_ONE_BYTE_MAX ? 2 : 1);
}

/** Set the number of fields for one new style leaf page record.
This is only needed for table after instant ADD COLUMN.
@param[in,out]	rec		leaf page record
@param[in]	n_fields	number of fields in the record
@return	the length of the n_fields occupies */
UNIV_INLINE
uint8_t rec_set_n_fields(rec_t *rec, ulint n_fields) {
  byte *ptr = rec - (REC_N_NEW_EXTRA_BYTES + 1);

  ut_ad(n_fields < REC_MAX_N_FIELDS);

  if (n_fields <= REC_N_FIELDS_ONE_BYTE_MAX) {
    *ptr = static_cast<byte>(n_fields);
    return (1);
  }

  --ptr;
  *ptr++ = static_cast<byte>(n_fields & 0xFF);
  *ptr = static_cast<byte>(n_fields >> 8);
  ut_ad((*ptr & 0x80) == 0);
  *ptr |= REC_N_FIELDS_TWO_BYTES_FLAG;

  return (2);
}

/** Gets the value of the specified field in the record in old style.
This is only used for record from instant index, which is clustered
index and has some instantly added columns.
@param[in]	rec	physical record
@param[in]	n	index of the field
@param[in]	index   clustered index where the record resides
@param[out]	len	length of the field, UNIV_SQL if SQL null
@return value of the field, could be either pointer to rec or default value */
UNIV_INLINE
const byte *rec_get_nth_field_old_instant(const rec_t *rec, uint16_t n,
                                          const dict_index_t *index,
                                          ulint *len) {
  ut_a(index != nullptr);

  if (n < rec_get_n_fields_old_raw(rec)) {
    return (rec_get_nth_field_old(rec, n, len));
  }

  const byte *field;

  ut_ad(index->has_instant_cols());

  field = index->get_nth_default(n, len);
  return (field);
}

/** Gets the value of the specified field in the record.
This is only used when there is possibility that the record comes from the
clustered index, which has some instantly add columns
@param[in]	rec	record
@param[in]	offsets	array returned by rec_get_offsets()
@param[in]	n	index of the field
@param[in]	index	clustered index where the record resides
@param[in,out]	len	length of the field, UNIV_SQL_NULL if SQL null
@return	value of the field, could be either pointer to rec or default value */
UNIV_INLINE
const byte *rec_get_nth_field_instant(const rec_t *rec, const ulint *offsets,
                                      ulint n, const dict_index_t *index,
                                      ulint *len) {
  ulint off = rec_get_nth_field_offs(offsets, n, len);

  if (*len != UNIV_SQL_ADD_COL_DEFAULT) {
    return (rec + off);
  }

  ut_a(index != nullptr);
  ut_ad(index->has_instant_cols());

  return (index->get_nth_default(n, len));
}
